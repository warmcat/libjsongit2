## Transparent JSON Cache

If the vhost config member `json_cache_base` is non-NULL, then it is used as
the base path for a transparent JSON cache.  When a job starts to generate some
content, a hash is generated using the following keys

 1. An epoch number set in libjsongit2 that allows whole caches to be
    invalidated when a mandatory format change occurs on a later version
    
 2. The job type (generate a commit view, or a snapshot, etc)
 
 3. The count (some jobs generate a requested amount of output only)
 
Then, if the urlpath implies a specific repo
 
 4. The repo refs hash, a hash generated from all ref oids and names in the
    repo
 
 5. repo dir (the filesystem dir of the repo, eg, /srv/repositories/myrepo.git)
 
 6. the urlpath mode (blame, tree, etc)

 7. urlpath filepath (the file inside the repo we are looking at)
 
If the urlpath did not imply a specific repo, then
 
 8. The HEAD oid of gitolite-admin, if any

 9. Every repo name accessible using the current vhost and ctx acl user.

The generated hash becomes the filename in the cache dir for the content.

Later, requests for jobs also have their hash computed the same way, only if
everything is the same (including the refs state of the repo...) will the
cached hash be arrived at the same.

Cache files are created with an appended pid and pointer to the ctx requesting
the job, since it's possible multiple contexts or other instances could have
also been asked to create the context before a cache entry exists.  When the
cache content generation is complete, the temp filename is renamed to the
final cacahe filename... if this fails because another instance got there first,
the temp cache file is simply deleted.

### Scope of cache

The cache operates on "content generated by a libjsongit2 job", usually JSON,
but it also operates on /plain/ (directly serve files from a repo with an
appropriate mimetype) and /snapshot/ (generate tarballs and zipfiles for a repo
ref).

It deliberately does not cover the vhost HTML template, the css, js etc loaded
by that nor the outer JSON braces and content there generated by libjsongit2.

This allows old cached content, still reflecting the current repo state, to be
served using the newest HTML, CSS, JS etc the same as freshly-generated content.
libjsongit2 also adds up-to-date dynamic information about page generation time
and cache statistics in the outer JSON whether the page contains some or
otherwise all cached JSON content; this is shown in the footer in the example
HTML template.

### Cache hashes and ETAG

libjsongit2 can compute the cache hash for URL + repo state output without
actually generating the contents.  This allows the cache hash to also be used
with [HTTP's RFC7232 ETAG](https://tools.ietf.org/html/rfc7232) scheme, where the browser is given the
cache hash along with the contents, and if it asks for it again where no
prerequisite has changed, can simply be told in the HTTP response code that
the version the browser has in its local cache is still current.

This allows requests for even dynamically-generated content like /plain/ and
/snapshot/ URLs to be completed with just the cache hash generation and
comparison, without doing any work or sending anything except the HTTP 304
notification, if the browser already has the same version we would have
generated and sent.  This is particularly effective when, eg, the README.md
in the root tree view has many pictures served from the versioned repo itself
and the user passes through it multiple times using the tree part.

### Cache maintenance

The amount of storage the cache is allowed to use can be limited using the
`.cache_size_limit` of `struct jg2_vhost_config` at vhost creation time.

A thread lazily scans the cache subdirs and sleeps for a second after each one.
Since there are 16 x 16 cache subdirs, it completes a scan every 256s (around
4 minutes).  As the cache is managed by LRU, the thread takes the approach
to only collect the names the 128 oldest files, regardless of how many files
there actually are.  So the cache management action is cheap, done lazily and
only uses a maximum of around 12KiB heap.

If at the end of the scan the thread sees the total storage exceeds the maximum,
it unlinks files on its list, starting with the oldest first until it's back
under the limit.  If 128 files weren't enough to get it under the limit, it will
start the next scan immediately and run it doing 8 cache subdirectories per
second (30s) until the excess is cleared.

If the cache is not near the maximum, scans are delayed according to an estimate
of how long it would take to reach the maximum, for no longer than an hour.

### Keeping bot spidering out of the JSON cache

If the libjsongit2 context is created with the flag bit JG2_CTX_FLAG_BOT set,
then although the access can use already-cached items, it is disabled from
creating new things in the cache.  This is because aggressive random spidering
will generate continuous "noise" cache content where the access has no
implication that another user may consider the content interesting in the
future, flushing out user-generated content that does imply it may be accessed
again.